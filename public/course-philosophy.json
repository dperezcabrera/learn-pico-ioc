{
  "title": "The Philosophy of DI in Python",
  "date": "2024-07-28",
  "levels": [
    {
      "id": 0,
      "type": "cover",
      "title": "Course Cover",
      "description": "Learn the fundamental principles of Dependency Injection and Inversion of Control in plain Python.",
      "files": [],
      "packages": []
    },
    {
      "id": 100,
      "type": "toc",
      "title": "Table of Contents",
      "description": "Select a level to begin your journey into the world of loosely-coupled code.",
      "files": [],
      "packages": []
    },
    {
      "id": 1,
      "type": "doc",
      "title": "What is Tight Coupling?",
      "description": "<h4>What is a Dependency?</h4><p>In software, when one piece of code (like a class or a function) needs another piece of code to do its job, we say it has a 'dependency'. For example, a <code>Car</code> class might need an <code>Engine</code> class to work.</p><h4>Tight Coupling: The Problem</h4><p>Let's look at an example. A <code>ReportGenerator</code> needs to get data from a database. A common, but problematic, approach is for the <code>ReportGenerator</code> to create its own database connection.</p><pre><code class='language-python'>class ReportGenerator:\n    def __init__(self):\n        # The ReportGenerator creates its own dependency.\n        # This is tight coupling.\n        self.database = PostgreSQLDatabase()\n\n    def generate(self):\n        data = self.database.fetch_data()\n        # ... create a report from the data</code></pre><p>This is called <strong>tight coupling</strong>. The <code>ReportGenerator</code> is permanently 'stuck' to the <code>PostgreSQLDatabase</code>. This causes several problems:</p><ul><li><strong>Hard to Test:</strong> How can you test the report generation logic without a real PostgreSQL database running? It's difficult and slow.</li><li><strong>Hard to Reuse:</strong> What if you want to generate a report from a different data source, like a MySQL database or a simple file? You can't, because <code>PostgreSQLDatabase</code> is hard-coded.</li><li><strong>Hard to Maintain:</strong> If the <code>PostgreSQLDatabase</code> constructor changes (e.g., it now needs a connection string), you have to find and change every place it's created, including inside <code>ReportGenerator</code>.</li></ul><p>In the next lab, you'll see this problem firsthand.</p>",
      "files": [],
      "packages": []
    },
    {
      "id": 2,
      "type": "lab",
      "title": "Your First Tightly Coupled Class",
      "description": "<h4>Observing The Problem</h4><p>Here we have a simple application. All the codeâ€”the <code>Database</code> class, the <code>ReportGenerator</code> class, and the main scriptâ€”is in a single file for simplicity.</p><p>Notice inside <code>ReportGenerator.__init__</code>, it creates its own <code>Database</code> instance. This is the tight coupling we just discussed.</p><p>Your task is to simply run the code by pressing the 'Run' button. Observe how the script uses the generator and see the output in the console. There's nothing to fix yetâ€”just understand how the pieces are connected.</p>",
      "files": [
        { 
          "name": "main.py", 
          "content": "# All code is in one file for simplicity.\n\n# --- Contents of database.py ---\nclass Database:\n    \"\"\"A mock database class.\"\"\"\n    def get_user_data(self) -> dict:\n        print(\"(DATABASE) Connecting and fetching data...\")\n        return {\"id\": 1, \"name\": \"Alice\"}\n\n# --- Contents of report.py ---\nclass ReportGenerator:\n    def __init__(self):\n        # This is tight coupling!\n        # The generator is responsible for creating its dependency.\n        self.db = Database()\n\n    def create_user_report(self) -> str:\n        user_data = self.db.get_user_data()\n        return f\"User Report: ID={user_data['id']}, Name={user_data['name']}\"\n\n# --- Main script ---\n# Create a generator\ngenerator = ReportGenerator()\n\n# Use it to create a report\nreport = generator.create_user_report()\n\nprint(report)\n" 
        }
      ],
      "packages": [],
      "solution": {}
    },
    {
      "id": 3,
      "type": "lab",
      "title": "The Challenge of Testing Coupled Code",
      "description": "<h4>Why is This Hard to Test?</h4><p>We're using the same code from the last level, but now we have a test. All the necessary classes have been placed in the <code>test_report.py</code> file alongside the test function for convenience.</p><p>But there's a problem. When we test <code>create_user_report</code>, it will always create and call the real <code>Database</code>. This is bad for testing because:</p><ul><li>We might not want to connect to a real database during tests.</li><li>We can't test how our report handles different data (e.g., a user with no name) because we can't control what the hard-coded database returns.</li></ul><p>Your task is to complete the test. Notice how difficult it is to make an assertion about what data was used. The test can only check the final string, and it will always be the same. The real challenge here is conceptualâ€”realizing *why* this is a flawed design.</p>",
      "files": [
        { 
          "name": "test_report.py", 
          "content": "# All code is in one file for simplicity.\n\n# --- Contents of database.py ---\nclass Database:\n    \"\"\"A mock database class.\"\"\"\n    def get_user_data(self) -> dict:\n        print(\"(DATABASE) Connecting and fetching data...\")\n        return {\"id\": 1, \"name\": \"Alice\"}\n\n# --- Contents of report.py ---\nclass ReportGenerator:\n    def __init__(self):\n        self.db = Database()\n\n    def create_user_report(self) -> str:\n        user_data = self.db.get_user_data()\n        return f\"User Report: ID={user_data['id']}, Name={user_data['name']}\"\n\n# --- Test ---\ndef test_create_user_report():\n    generator = ReportGenerator()\n    report = generator.create_user_report()\n    \n    # ðŸ‘ˆ We can only assert the final output.\n    # We can't control the data, so the test is not very flexible.\n    assert report == \"User Report: ID=1, Name=Alice\"\n    \n    # How could we test with a different user, like Bob?\n    # With this design, we can't!\n" 
        }
      ],
      "packages": ["pytest"],
      "solution": {
        "test_report.py": "# All code is in one file for simplicity.\n\n# --- Contents of database.py ---\nclass Database:\n    \"\"\"A mock database class.\"\"\"\n    def get_user_data(self) -> dict:\n        print(\"(DATABASE) Connecting and fetching data...\")\n        return {\"id\": 1, \"name\": \"Alice\"}\n\n# --- Contents of report.py ---\nclass ReportGenerator:\n    def __init__(self):\n        self.db = Database()\n\n    def create_user_report(self) -> str:\n        user_data = self.db.get_user_data()\n        return f\"User Report: ID={user_data['id']}, Name={user_data['name']}\"\n\n# --- Test ---\ndef test_create_user_report():\n    generator = ReportGenerator()\n    report = generator.create_user_report()\n    \n    # ðŸ‘ˆ We can only assert the final output.\n    # We can't control the data, so the test is not very flexible.\n    assert report == \"User Report: ID=1, Name=Alice\"\n    \n    # How could we test with a different user, like Bob?\n    # With this design, we can't!\n"
      }
    },
    {
      "id": 4,
      "type": "doc",
      "title": "Inversion of Control & Setter Injection",
      "description": "<h4>The Solution: Inversion of Control</h4><p>To fix tight coupling, we use a principle called <strong>Inversion of Control (IoC)</strong>. The name sounds complex, but the idea is simple:</p><p><em>Instead of a class creating its own dependencies, we give the dependencies to the class from the outside.</em></p><p>The 'control' over creating dependencies is 'inverted'â€”it moves from inside the class to outside the class.</p><h4>Pattern 1: Setter Injection</h4><p>One way to implement IoC is with 'Setter Injection'. We add a method or property to our class that allows us to 'set' the dependency after the object has been created.</p><pre><code class='language-python'>class ReportGenerator:\n    def __init__(self):\n        # The dependency is no longer created here.\n        self.database = None # It starts empty\n\n    def set_database(self, db: Database):\n        # An external piece of code will call this method.\n        self.database = db\n\n    def generate(self):\n        if not self.database:\n            raise Exception(\"Database not set!\")\n        data = self.database.fetch_data()\n        # ... create a report\n\n# --- Code that USES the class ---\ndb_connection = PostgreSQLDatabase()\ngenerator = ReportGenerator()\ngenerator.set_database(db_connection) # Control is inverted!\n</code></pre><p>Now, our <code>ReportGenerator</code> is no longer tied to one type of database. We can give it any database object we want, which is great for flexibility and testing. In the next lab, you'll implement this pattern.</p>",
      "files": [],
      "packages": []
    },
    {
      "id": 5,
      "type": "lab",
      "title": "Implementing Setter Injection",
      "description": "<h4>Refactoring Time!</h4><p>It's time to apply the Setter Injection pattern. You need to modify the <code>ReportGenerator</code> class in the editor below.</p><p>Your tasks are:</p><ol><li>Modify the <code>__init__</code> method so it no longer creates the <code>Database</code> instance. Initialize <code>self.db</code> to <code>None</code> instead.</li><li>Create a new method called <code>set_database</code> that takes one argument and assigns it to <code>self.db</code>.</li></ol><p>I've already updated the main script section to use this new pattern. Once you've correctly refactored the class, press 'Run' and the code should work.</p>",
      "files": [
        { 
          "name": "main.py", 
          "content": "# All code is in one file for simplicity.\n\n# --- Contents of database.py ---\nclass Database:\n    def get_user_data(self) -> dict:\n        return {\"id\": 1, \"name\": \"Alice\"}\n\n# --- Contents of report.py ---\nclass ReportGenerator:\n    # ðŸ‘ˆ 1. Change __init__ to not create the Database.\n    #         Initialize self.db to None.\n    def __init__(self):\n        self.db = Database()\n\n    # ðŸ‘ˆ 2. Add a new method `set_database` that accepts a\n    #         database object and assigns it to self.db.\n\n    def create_user_report(self) -> str:\n        user_data = self.db.get_user_data()\n        return f\"User Report: ID={user_data['id']}, Name={user_data['name']}\"\n\n# --- Main script ---\n# The controlling code now creates the dependency.\ndb_instance = Database()\n\n# Create the generator (it's empty for now).\ngenerator = ReportGenerator()\n\n# Inject the dependency using our new setter method.\ngenerator.set_database(db_instance)\n\n# Now we can create the report.\nreport = generator.create_user_report()\nprint(report)\n" 
        }
      ],
      "packages": [],
      "solution": {
        "main.py": "# All code is in one file for simplicity.\n\n# --- Contents of database.py ---\nclass Database:\n    def get_user_data(self) -> dict:\n        return {\"id\": 1, \"name\": \"Alice\"}\n\n# --- Contents of report.py ---\nclass ReportGenerator:\n    def __init__(self):\n        self.db = None\n\n    def set_database(self, database: object):\n        self.db = database\n\n    def create_user_report(self) -> str:\n        if not self.db:\n            raise ValueError(\"Database has not been set.\")\n        user_data = self.db.get_user_data()\n        return f\"User Report: ID={user_data['id']}, Name={user_data['name']}\"\n\n# --- Main script ---\n# The controlling code now creates the dependency.\ndb_instance = Database()\n\n# Create the generator (it's empty for now).\ngenerator = ReportGenerator()\n\n# Inject the dependency using our new setter method.\ngenerator.set_database(db_instance)\n\n# Now we can create the report.\nreport = generator.create_user_report()\nprint(report)\n"
      }
    },
    {
      "id": 6,
      "type": "doc",
      "title": "A Better Way: Constructor Injection",
      "description": "<h4>The Perils of Mutable Dependencies</h4><p>With Setter Injection, some other piece of code is now responsible for wiring everything together. Let's call this the <strong>Orchestrator</strong> or <strong>Assembler</strong>. This pattern is powerful, but it has a weakness: the object is mutable. The dependency can be changed at any time, or the orchestrator might forget to set it.</p><pre><code class='language-python'>generator = ReportGenerator()\ngenerator.set_database(PostgreSQLDatabase()) # Works!\n\n# ... but later, another piece of code can change it!\ngenerator.set_database(MySQLDatabase())\n\n# Or even worse, the orchestrator forgets a step!\ngenerator = ReportGenerator()\ngenerator.generate() # Fails!</code></pre><p>This means the object can exist in an incomplete state. It's safer to ensure that once an object is created, it has everything it needs to be valid.</p><h4>Pattern 2: Constructor Injection</h4><p>This is the most common and preferred method of DI. The concept is straightforward: <em>Pass the dependencies as arguments to the class's constructor (the <code>__init__</code> method).</em></p><pre><code class='language-python'>class ReportGenerator:\n    def __init__(self, database: Database):\n        self.database = database\n\n# --- Code that USES the class ---\ndb_connection = PostgreSQLDatabase()\ngenerator = ReportGenerator(database=db_connection)\n</code></pre><h4>Why is this better?</h4><ul><li><strong>Immutability:</strong> The dependency is set once, at creation.</li><li><strong>Guaranteed Validity:</strong> An instance cannot be created *without* its required dependency.</li><li><strong>Clear Dependencies:</strong> The <code>__init__</code> signature tells you exactly what the class needs.</li></ul></p>",
      "files": [],
      "packages": []
    },
    {
      "id": 7,
      "type": "lab",
      "title": "Refactoring to Constructor Injection",
      "description": "<h4>The Final Refactor</h4><p>Let's refactor the <code>ReportGenerator</code> to use Constructor Injection.</p><p>Your tasks in the <code>ReportGenerator</code> class:</p><ol><li>Remove the <code>set_database</code> method entirely.</li><li>Modify the <code>__init__</code> method to accept a <code>database</code> argument.</li><li>Inside <code>__init__</code>, assign the passed-in <code>database</code> argument to <code>self.db</code>.</li></ol><p>I've updated the main script section to create the <code>ReportGenerator</code> using this new constructor. Once your changes are correct, the code will run successfully.</p>",
      "files": [
        { 
          "name": "main.py", 
          "content": "# All code is in one file for simplicity.\n\n# --- Contents of database.py ---\nclass Database:\n    def get_user_data(self) -> dict:\n        return {\"id\": 1, \"name\": \"Alice\"}\n\n# --- Contents of report.py ---\nclass ReportGenerator:\n    # ðŸ‘ˆ 1. Modify __init__ to accept a `database` argument.\n    # ðŸ‘ˆ 2. Assign the argument to self.db.\n    def __init__(self):\n        self.db = None\n\n    # ðŸ‘ˆ 3. Remove the set_database method.\n    def set_database(self, database: object):\n        self.db = database\n\n    def create_user_report(self) -> str:\n        user_data = self.db.get_user_data()\n        return f\"User Report: ID={user_data['id']}, Name={user_data['name']}\"\n\n# --- Main script ---\n# The controlling code creates the dependency.\ndb_instance = Database()\n\n# The dependency is \"injected\" into the constructor.\ngenerator = ReportGenerator(database=db_instance)\n\n# The generator is ready to use immediately.\nreport = generator.create_user_report()\nprint(report)\n" 
        }
      ],
      "packages": [],
      "solution": {
        "main.py": "# All code is in one file for simplicity.\n\n# --- Contents of database.py ---\nclass Database:\n    def get_user_data(self) -> dict:\n        return {\"id\": 1, \"name\": \"Alice\"}\n\n# --- Contents of report.py ---\nclass ReportGenerator:\n    def __init__(self, database: object):\n        self.db = database\n\n    def create_user_report(self) -> str:\n        user_data = self.db.get_user_data()\n        return f\"User Report: ID={user_data['id']}, Name={user_data['name']}\"\n\n# --- Main script ---\n# The controlling code creates the dependency.\ndb_instance = Database()\n\n# The dependency is \"injected\" into the constructor.\ngenerator = ReportGenerator(database=db_instance)\n\n# The generator is ready to use immediately.\nreport = generator.create_user_report()\nprint(report)\n"
      }
    },
    {
      "id": 8,
      "type": "doc",
      "title": "Simplifying Creation with Factories",
      "description": "<h4>The Assembler Role & Factories</h4><p>As your application grows, the code that creates and wires together your objects (the 'assembler' or 'composition root') can get complicated.</p><pre><code class='language-python'># This can get long and complex!\ndb_connection = Database(connection_string=\"...\")\ncache = RedisCache(host=\"localhost\")\nuser_service = UserService(db=db_connection, cache=cache)\norder_service = OrderService(db=db_connection, ...)\n</code></pre><p>To keep this organized, we can use a <strong>Factory</strong>â€”a function whose only job is to create a configured object. This separates the 'what' (I need a <code>UserService</code>) from the 'how' (you need to build a <code>Database</code> and a <code>Cache</code> first).</p><pre><code class='language-python'>def create_user_service() -> UserService:\n    db_connection = Database(connection_string=\"...\")\n    cache = RedisCache(host=\"localhost\")\n    return UserService(db=db_connection, cache=cache)\n\n# --- Main application code ---\nuser_service = create_user_service()\n</code></pre><p>This is a great step for organization, but it has a hidden problem we'll explore next.</p>",
      "files": [],
      "packages": []
    },
    {
      "id": 9,
      "type": "lab",
      "title": "Building Your First Factory",
      "description": "<h4>Organizing Object Creation</h4><p>Let's put the Factory Function pattern into practice. We have our familiar <code>Database</code> and <code>ReportGenerator</code> classes.</p><p>Your task is to complete the <code>create_report_generator</code> function in the <code>factories.py</code> file. It should:</p><ol><li>Create an instance of the <code>Database</code>.</li><li>Create an instance of the <code>ReportGenerator</code>, passing the database instance to its constructor.</li><li>Return the fully configured <code>ReportGenerator</code> instance.</li></ol><p><code>test_main.py</code> is already written to use your factory. Get the factory working, press 'Run', and the test will pass.</p>",
      "files": [
        { "name": "database.py", "content": "import time\n_instance_counter = 0\nclass Database:\n    def __init__(self):\n        global _instance_counter\n        _instance_counter += 1\n        self.instance_id = _instance_counter\n        print(f\"(DATABASE) Creating instance #{self.instance_id}\")\n\n    def get_user_data(self) -> dict:\n        return {\"id\": 1, \"name\": \"Alice\"}\n" },
        { "name": "report.py", "content": "from database import Database\n\nclass ReportGenerator:\n    def __init__(self, database: Database):\n        self.db = database\n\n    def create_user_report(self) -> str:\n        user_data = self.db.get_user_data()\n        return f\"User Report (from DB instance #{self.db.instance_id}): ID={user_data['id']}, Name={user_data['name']}\"\n" },
        { "name": "factories.py", "content": "from database import Database\nfrom report import ReportGenerator\n\ndef create_report_generator() -> ReportGenerator:\n    # ðŸ‘ˆ Implement this factory function.\n    # 1. Create a Database instance.\n    # 2. Create a ReportGenerator instance, injecting the database.\n    # 3. Return the generator.\n    pass\n" },
        { "name": "test_main.py", "content": "from factories import create_report_generator\nfrom report import ReportGenerator\n\ndef test_factory():\n    print(\"--- First call ---\")\n    generator1 = create_report_generator()\n    assert isinstance(generator1, ReportGenerator)\n    report1 = generator1.create_user_report()\n    print(report1)\n    assert \"DB instance #1\" in report1\n\n    print(\"\\n--- Second call ---\")\n    generator2 = create_report_generator()\n    report2 = generator2.create_user_report()\n    print(report2)\n    assert \"DB instance #2\" in report2\n    \n    print(\"\\nNotice that a new Database instance was created each time.\")\n" }
      ],
      "packages": ["pytest"],
      "solution": {
        "factories.py": "from database import Database\nfrom report import ReportGenerator\n\ndef create_report_generator() -> ReportGenerator:\n    db_instance = Database()\n    generator = ReportGenerator(database=db_instance)\n    return generator\n"
      }
    },
    {
      "id": 10,
      "type": "doc",
      "title": "From Factories to Containers",
      "description": "<h4>The Problem with Simple Factories</h4><p>In the last lab, did you notice that a new <code>Database</code> instance was created every single time we called the factory? For some things, like a simple formatter, that's fine. But for a database connection, a cache, or a configuration object, creating a new one every time is inefficient and often wrong. For some components, we want to create them once and <strong>reuse</strong> the same instance everywhere.</p><h4>The Container: A Smart Factory</h4><p>This is where the idea of a <strong>Container</strong> comes from. A container is an object that knows how to create and manage the lifecycle of all our components.</p><p>You can think of it as a smart factory or a registry. You configure it once at the start of your application:</p><ol><li>You tell it what classes are available (e.g., <code>Database</code>, <code>ReportGenerator</code>).</li><li>You tell it if a component should be reused (e.g., <code>Database</code> should be reused, but a <code>ReportGenerator</code> might be new every time).</li></ol><p>Then, for the rest of your application's life, you just ask the container for the objects you need. The container handles the complex assembly for you.</p><pre><code class='language-python'># A conceptual DI Container\ncontainer = Container()\n\n# Configuration phase\ncontainer.register(Database, reuse=True)\ncontainer.register(ReportGenerator, reuse=False)\n\n# --- Later in your app ---\n# Usage phase\ngenerator1 = container.get(ReportGenerator)\ngenerator2 = container.get(ReportGenerator)\n\n# generator1.db is the EXACT SAME object as generator2.db\n# because the container reused the Database instance.</code></pre><p>In the next lab, we'll build a simple version of this container to see how it works.</p>",
      "files": [],
      "packages": []
    },
    {
      "id": 11,
      "type": "lab",
      "title": "Building a Simple Container",
      "description": "<h4>Let's Demystify the Container</h4><p>A DI Container can seem like magic, but it's just code. Let's build a basic one to understand the core principles of registration and resolution.</p><p>Your task is to complete the <code>Container</code> class:</p><ol><li>In the <code>register</code> method, store the class and its `reuse` flag in the <code>_services</code> dictionary.</li><li>In the <code>get</code> method, you need to implement the resolution logic:</li><ul><li>Find the configuration for the requested class.</li><li>If its `reuse` flag is `True`, check if an instance already exists in the <code>_cache</code>. If so, return it.</li><li>If `reuse` is `True` but it's not cached yet, create a new instance, store it in the cache, and then return it.</li><li>If its `reuse` flag is `False`, always create and return a brand new instance.</li></ul></ol><p>The test code at the bottom will verify that your container correctly reuses the `Database` instance but creates a new `UserService` each time.</p>",
      "files": [
        {
          "name": "main.py",
          "content": "_db_counter = 0\nclass Database:\n    def __init__(self):\n        global _db_counter\n        _db_counter += 1\n        self.instance_id = _db_counter\n        print(f\"(DATABASE) Instance #{self.instance_id} created.\")\n\n_user_service_counter = 0\nclass UserService:\n    def __init__(self, db: Database):\n        global _user_service_counter\n        _user_service_counter += 1\n        self.instance_id = _user_service_counter\n        self.db = db\n        print(f\"(SERVICE) Instance #{self.instance_id} created, using DB #{db.instance_id}.\")\n\nclass Container:\n    def __init__(self):\n        self._services = {} # Stores configuration\n        self._cache = {}    # Stores reused instances\n\n    def register(self, cls, reuse: bool = False):\n        # ðŸ‘ˆ 1. Store the class and its `reuse` flag.\n        #    Hint: self._services[cls] = {'reuse': reuse}\n        pass\n\n    def get(self, cls):\n        # ðŸ‘ˆ 2. Implement the logic to get a service based on `reuse`.\n        # - Find the config for `cls` in self._services.\n        # - If config says `reuse=True`:\n        #   - Check the self._cache for an existing instance.\n        #   - If found, return it.\n        #   - If not found, create one, store it in the cache, and return it.\n        # - If config says `reuse=False`, just create and return a new instance.\n        # - This simple version doesn't handle dependency resolution automatically.\n        return None\n\n# --- Test ---\ncontainer = Container()\ncontainer.register(Database, reuse=True)\ncontainer.register(UserService, reuse=False)\n\nprint(\"--- Testing Database (reuse=True) ---\")\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nprint(f\"Are db1 and db2 the same object? {db1 is db2}\\n\")\nassert db1 is db2\n\nprint(\"--- Testing UserService (reuse=False) ---\")\n# Manual dependency injection using the container\n# We get a new UserService instance each time because reuse=False.\nservice1 = UserService(db=container.get(Database))\nservice2 = UserService(db=container.get(Database))\nprint(f\"Are service1 and service2 the same object? {service1 is not service2}\")\nassert service1 is not service2\nprint(f\"Does service2 use the same DB instance? {service2.db is db1}\")\nassert service2.db is db1\n"
        }
      ],
      "packages": ["pytest"],
      "solution": {
        "main.py": "_db_counter = 0\nclass Database:\n    def __init__(self):\n        global _db_counter\n        _db_counter += 1\n        self.instance_id = _db_counter\n        print(f\"(DATABASE) Instance #{self.instance_id} created.\")\n\n_user_service_counter = 0\nclass UserService:\n    def __init__(self, db: Database):\n        global _user_service_counter\n        _user_service_counter += 1\n        self.instance_id = _user_service_counter\n        self.db = db\n        print(f\"(SERVICE) Instance #{self.instance_id} created, using DB #{db.instance_id}.\")\n\nclass Container:\n    def __init__(self):\n        self._services = {} # Stores configuration\n        self._cache = {}    # Stores reused instances\n\n    def register(self, cls, reuse: bool = False):\n        self._services[cls] = {'reuse': reuse}\n\n    def get(self, cls):\n        config = self._services.get(cls)\n        if not config:\n            raise TypeError(f\"Service {cls.__name__} not registered.\")\n        \n        if config['reuse']:\n            if cls not in self._cache:\n                # This simple version doesn't resolve dependencies of the class itself.\n                self._cache[cls] = cls()\n            return self._cache[cls]\n        \n        # If not reusing, always create a new one.\n        return cls()\n\n# --- Test ---\ncontainer = Container()\ncontainer.register(Database, reuse=True)\ncontainer.register(UserService, reuse=False)\n\nprint(\"--- Testing Database (reuse=True) ---\")\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nprint(f\"Are db1 and db2 the same object? {db1 is db2}\\n\")\nassert db1 is db2\n\nprint(\"--- Testing UserService (reuse=False) ---\")\n# Manual dependency injection using the container\n# We get a new UserService instance each time because reuse=False.\nservice1 = UserService(db=container.get(Database))\nservice2 = UserService(db=container.get(Database))\nprint(f\"Are service1 and service2 the same object? {service1 is not service2}\")\nassert service1 is not service2\nprint(f\"Does service2 use the same DB instance? {service2.db is db1}\")\nassert service2.db is db1\n"
      }
    },
    {
      "id": 12,
      "type": "doc",
      "title": "Programming to an Interface",
      "description": "<h4>Decoupling with Abstractions</h4><p>So far, our classes have depended on other *concrete* classes (e.g., <code>UserService</code> depends on <code>Database</code>). This is a huge improvement, but we can go one step further by depending on an *abstraction* instead.</p><p>In Python, we can define abstractions using <code>typing.Protocol</code>. A protocol defines a 'contract'â€”what methods and properties an object must haveâ€”without providing an implementation.</p><pre><code class='language-python'>from typing import Protocol\n\nclass PaymentProcessor(Protocol):\n    \"\"\"A contract for any class that can process payments.\"\"\"\n    def charge(self, amount: float) -> bool:\n        ...\n\nclass StripeProcessor:\n    def charge(self, amount: float) -> bool:\n        print(f\"Charging ${amount} with Stripe.\")\n        return True\n\nclass PayPalProcessor:\n    def charge(self, amount: float) -> bool:\n        print(f\"Charging ${amount} with PayPal.\")\n        return True\n</code></pre><p>Now, our business logic can depend on the <code>PaymentProcessor</code> protocol, not a specific implementation. This is powerful because we can swap <code>StripeProcessor</code> for <code>PayPalProcessor</code> without changing the business logic code at all. This is an example of the <strong>Liskov Substitution Principle</strong>.</p><pre><code class='language-python'>class Store:\n    # Depends on the abstraction, not the concrete class!\n    def __init__(self, payment_processor: PaymentProcessor):\n        self._processor = payment_processor\n\n    def checkout(self, cart_total: float):\n        self._processor.charge(cart_total)\n</code></pre>",
      "files": [],
      "packages": []
    },
    {
      "id": 13,
      "type": "lab",
      "title": "Injecting Multiple Implementations",
      "description": "<h4>The Strategy Pattern</h4><p>A powerful use of DI is to provide multiple implementations of the same interface. Imagine a service that needs to send a notification through all available channels (Email, SMS, etc.).</p><p>We have a <code>Notifier</code> protocol and two implementations: <code>EmailNotifier</code> and <code>SMSNotifier</code>. The <code>NotificationService</code> is designed to accept a *list* of notifiers in its constructor.</p><p>Your task is to use the provided <code>Container</code> to:</p><ol><li>Register both <code>EmailNotifier</code> and <code>SMSNotifier</code> as implementations of the <code>Notifier</code> protocol.</li><li>Register the <code>NotificationService</code> itself.</li><li>Get an instance of <code>NotificationService</code>. The container is smart enough to see the <code>list[Notifier]</code> type hint and will inject both registered notifiers automatically.</li><li>Call the <code>send_all</code> method and observe the output.</li></ol>",
      "files": [
        {
          "name": "main.py",
          "content": "from typing import Protocol, Type, get_origin, get_args\n\n# --- Protocols and Implementations ---\nclass Notifier(Protocol):\n    def send(self, message: str):\n        ...\n\nclass EmailNotifier:\n    def send(self, message: str):\n        print(f\"EMAIL: {message}\")\n\nclass SMSNotifier:\n    def send(self, message: str):\n        print(f\"SMS: {message}\")\n\nclass NotificationService:\n    def __init__(self, notifiers: list[Notifier]):\n        self._notifiers = notifiers\n    \n    def send_all(self, message: str):\n        print(f\"Sending '{message}' to {len(self._notifiers)} channels...\")\n        for notifier in self._notifiers:\n            notifier.send(message)\n\n# --- A more advanced container ---\nclass Container:\n    def __init__(self):\n        self._providers = {}\n\n    def register(self, interface, concrete):\n        if interface not in self._providers:\n            self._providers[interface] = []\n        self._providers[interface].append(concrete)\n\n    def get(self, cls):\n        if get_origin(cls) is list:\n            item_type = get_args(cls)[0]\n            implementations = self._providers.get(item_type, [])\n            return [impl() for impl in implementations]\n        \n        # This simple container assumes the class has dependencies that are lists\n        if cls in self._providers:\n            # A real container would inspect __init__ properly\n            # For this lab, we hardcode the dependency resolution for NotificationService\n            if cls is NotificationService:\n                notifiers = self.get(list[Notifier])\n                return NotificationService(notifiers=notifiers)\n        \n        return cls()\n\n# --- Your Task ---\ncontainer = Container()\n\n# 1. Register EmailNotifier and SMSNotifier for the Notifier protocol\n# Hint: container.register(Notifier, EmailNotifier)\n\n# 2. Register the NotificationService itself\n# Hint: container.register(NotificationService, NotificationService)\n\n# 3. Get the NotificationService from the container\n# service = container.get(NotificationService)\n\n# 4. Call the send_all method\n# service.send_all(\"Hello, World!\")\n"
        }
      ],
      "packages": ["pytest"],
      "solution": {
        "main.py": "from typing import Protocol, Type, get_origin, get_args\n\n# --- Protocols and Implementations ---\nclass Notifier(Protocol):\n    def send(self, message: str):\n        ...\n\nclass EmailNotifier:\n    def send(self, message: str):\n        print(f\"EMAIL: {message}\")\n\nclass SMSNotifier:\n    def send(self, message: str):\n        print(f\"SMS: {message}\")\n\nclass NotificationService:\n    def __init__(self, notifiers: list[Notifier]):\n        self._notifiers = notifiers\n    \n    def send_all(self, message: str):\n        print(f\"Sending '{message}' to {len(self._notifiers)} channels...\")\n        for notifier in self._notifiers:\n            notifier.send(message)\n\n# --- A more advanced container ---\nclass Container:\n    def __init__(self):\n        self._providers = {}\n\n    def register(self, interface, concrete):\n        if interface not in self._providers:\n            self._providers[interface] = []\n        self._providers[interface].append(concrete)\n\n    def get(self, cls):\n        if get_origin(cls) is list:\n            item_type = get_args(cls)[0]\n            implementations = self._providers.get(item_type, [])\n            return [impl() for impl in implementations]\n        \n        if cls in self._providers:\n            if cls is NotificationService:\n                notifiers = self.get(list[Notifier])\n                return NotificationService(notifiers=notifiers)\n        \n        return cls()\n\n# --- Your Task ---\ncontainer = Container()\n\n# 1. Register EmailNotifier and SMSNotifier for the Notifier protocol\ncontainer.register(Notifier, EmailNotifier)\ncontainer.register(Notifier, SMSNotifier)\n\n# 2. Register the NotificationService itself\ncontainer.register(NotificationService, NotificationService)\n\n# 3. Get the NotificationService from the container\nservice = container.get(NotificationService)\n\n# 4. Call the send_all method\nservice.send_all(\"Hello from the Container!\")\n"
      }
    },
    {
      "id": 14,
      "type": "doc",
      "title": "Dealing with Legacy Code",
      "description": "<h4>The Untouchable Code</h4><p>In the real world, you'll often encounter code you can't easily change. A common example is a library with static functions. This code is hard to test and doesn't fit our DI model because we can't inject it or replace it with a mock.</p><pre><code class='language-python'># In a third-party library you cannot modify\nclass LegacyEmailUtil:\n    @staticmethod\n    def send_email(address, subject, body):\n        # ... complex, slow, real email sending logic ...\n        print(f\"LEGACY: Sending email to {address}\")\n\nclass MyService:\n    def do_work(self):\n        # ... some logic ...\n        # This is a direct, untestable call to static code.\n        LegacyEmailUtil.send_email(\"a@b.com\", \"Hi\", \"Test\")\n</code></pre><h4>The Wrapper/Adapter Pattern</h4><p>The solution is to create a thin **Wrapper** (or **Adapter**) class around the legacy code. This wrapper is *your* code, so you control it. It doesn't contain logic; it just delegates the call to the legacy code.</p><pre><code class='language-python'># You write this wrapper class\nclass EmailSender:\n    def send(self, address, subject, body):\n        LegacyEmailUtil.send_email(address, subject, body)\n</code></pre><p>Now, your service can depend on *your* `EmailSender` wrapper. You can inject it via the constructor just like any other dependency. For testing, you can easily create a `MockEmailSender` and inject that instead. You've made the untestable testable!</p><pre><code class='language-python'>class MyService:\n    def __init__(self, email_sender: EmailSender):\n        self._sender = email_sender\n\n    def do_work(self):\n        # ... some logic ...\n        # Now it's a clean, injectable call!\n        self._sender.send(\"a@b.com\", \"Hi\", \"Test\")\n</code></pre>",
      "files": [],
      "packages": []
    },
    {
      "id": 15,
      "type": "lab",
      "title": "The Payoff: Testing with Mock Objects",
      "description": "<h4>Easy, Flexible Testing</h4><p>We've reached the final and most important benefit of DI: <strong>testability</strong>. Because our <code>ReportGenerator</code> accepts its dependency via the constructor, we can give it a *real* database in our main app, but a *fake* one in our tests!</p><p>This fake object is often called a 'mock' or 'test double'.</p><p>Your task is to complete <code>test_report.py</code>. I've started a <code>MockDatabase</code> for you.</p><ol><li>In <code>MockDatabase</code>, create a method <code>get_user_data</code> that returns a dictionary with test data (e.g., user 'Bob').</li><li>In <code>test_generator_with_mock</code>, create an instance of your <code>MockDatabase</code>.</li><li>Inject your mock into a new <code>ReportGenerator</code> instance.</li><li>Call <code>create_user_report</code> and assert that the output string contains the mock data you defined.</li></ol>",
      "files": [
        { "name": "database.py", "content": "class Database:\n    def get_user_data(self) -> dict:\n        # This is the real implementation\n        return {\"id\": 1, \"name\": \"Alice\"}\n" },
        { "name": "report.py", "content": "from database import Database\n\nclass ReportGenerator:\n    def __init__(self, database: Database):\n        self.db = database\n\n    def create_user_report(self) -> str:\n        user_data = self.db.get_user_data()\n        return f\"User Report: ID={user_data['id']}, Name={user_data['name']}\"\n" },
        { "name": "test_report.py", "content": "from report import ReportGenerator\n\nclass MockDatabase:\n    \"\"\"A fake database for testing purposes.\"\"\"\n    # ðŸ‘ˆ 1. Implement a `get_user_data` method that returns\n    #         a dictionary for a test user, e.g., Bob.\n    pass\n\ndef test_generator_with_mock():\n    # ðŸ‘ˆ 2. Create an instance of MockDatabase.\n    mock_db = None\n    \n    # ðŸ‘ˆ 3. Create a ReportGenerator, injecting the mock.\n    generator = None\n    \n    # 4. Call the method and get the report.\n    report = generator.create_user_report()\n    \n    # ðŸ‘ˆ 5. Assert the report contains your mock user's name.\n    assert \"??\" in report\n" }
      ],
      "packages": ["pytest"],
      "solution": {
        "test_report.py": "from report import ReportGenerator\n\nclass MockDatabase:\n    \"\"\"A fake database for testing purposes.\"\"\"\n    def get_user_data(self) -> dict:\n        return {\"id\": 2, \"name\": \"Bob\"}\n\ndef test_generator_with_mock():\n    # Create an instance of our fake database.\n    mock_db = MockDatabase()\n    \n    # Inject the mock into the class we are testing.\n    generator = ReportGenerator(database=mock_db)\n    \n    # Call the method.\n    report = generator.create_user_report()\n    \n    # Assert that the output used our mock data!\n    assert \"User Report: ID=2, Name=Bob\" in report\n"
      }
    },
    {
      "id": 16,
      "type": "doc",
      "title": "Congratulations & Next Steps",
      "description": "<h4>Course Complete!</h4><p>Congratulations! You've successfully learned the fundamental patterns and philosophy behind Inversion of Control and Dependency Injection in Python. You now understand:</p><ul><li>The problems with <strong>tightly coupled</strong> code.</li><li>How <strong>Inversion of Control</strong> and <strong>Constructor Injection</strong> solve these problems.</li><li>How to use <strong>Factories</strong> to organize object creation.</li><li>How <strong>Containers</strong> evolve from factories to manage component lifecycles (e.g., creating a component once and <strong>reusing it</strong>).</li><li>How to program to an <strong>interface (Protocol)</strong> and inject multiple implementations.</li><li>How to make legacy code testable with the <strong>Wrapper/Adapter</strong> pattern.</li><li>The ultimate benefit: clean, fast, and flexible <strong>unit testing with mocks</strong>.</li></ul><h4>What's Next?</h4><p>You've done all the wiring manually, and even built a simple container. For large applications, this becomes tedious. This is where <strong>DI Frameworks</strong> come in. They are tools that automate the process of creating, managing, and injecting dependencies.</p><p>Our other course, \"Learn Dependency injection with Python & pico-ioc\", is the perfect next step. It will teach you how to use a lightweight and powerful DI container to do all of this work for you automatically. You'll recognize all the patterns you learned here, but you'll see how a container makes applying them effortless.</p>",
      "files": [],
      "packages": []
    }
  ]
}